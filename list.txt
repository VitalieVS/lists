0:5:2[] adds 
[2*x | x <- [1..20]]
[2*x | x <- [1..100], 3 < x, x < 7]
[(m,n) | m <- [1..3], n <- [1..3]] va crea combinatiile posibile p/u m si n - 1 1 , 12 ,13 ...
factor n = [m | m <- [1..n `div` 2], mod n m == 0] o lista a divizorilor numarului...
head - primu, tail - toata lista bez ultimu 

map - ca arg o lista de valori si o functie care trebuie aplicata la fiecare valoare
map toUpper "helloword" 
Prelude Data.Char> map (*2) [1,2,3]
[2,4,6]
Prelude Data.Char> map(\ x->x+1) [1,2,3]
[2,3,4]

filter - functia - datele 

foldr are 3 argumente, o functie, o valoare initiala si o lista 
de ex [5,3,4,2,9] foldr (+5) 5 lista va fi de genu: 5:3:4:2:9:[] si obtinem 5+3+4+2+9+5 care aduna 5 la suma elementelor din lista


foldl - impachetarea la stinga foldl (/) 3 [36,2,3] 1.38888888888888e-2


xs !! n — получим n-й произвольный элемент списка xs, начиная с нулевого;
head xs — вернет первый элемент списка xs;
last xs — вернет последний элемент списка xs;
tail xs — вернет список xs без первого элемента;
init xs — вернет список xs без последнего элемента;
reverse xs — вернет обратный список;
length xs — вернет длину списка xs;

x:xs — добавит x в качестве нового головного (нулевого) элемента к списку xs;
xs ++ [x] — добавит x в качестве последнеого элемента к списку xs;
list1 ++ list2 — конкатенация двух списков list1 и list2;

drop n xs — вернет список, где удалены первых n элементов из списка xs;
take n xs — вернет список из первых n элементов из списка xs;
splitAt n xs — вернет пару списков, полученных из списка xs разбиением c n-й позиции (причем n-й элемент войдет во второй список);

Задание к уроку. Напишите функцию slice, которая работает как срезы (слайсы, slices) в таких языках как Python и Perl. Другими словами, должно быть что-то типа такого

> slice 2 3 [2.3, 7.4, 5.66, 6.1, 7.0]
[5.66, 6.1]

null xs — проверяет, пуст ли список xs (возвращает True или False);
x `elem` xs — проверит, лежит ли элемент x в списке xs (возвращает True или False);
any test xs — вернет True, если какой-либо элемент списка удовлетворяет условию test (если тип списка [a], то тип функции test должен быть a -> Bool);
all test xs — вернет True, если все элементы списка удовлетворяет условию test (с аналогичными выше требованиями);
filter test xs — вернет только те элементы списка, которые удовлетворяют условию test (с аналогичными выше требованиями);

Prelude> let xs = [1,2,322,100]
Prelude> filter (\x -> if x>1 then True else False) xs
Prelude> [2,322,100]

map f xs — применит функцию f ко всем элементам списка xs и вернет новый список;
map (\x -> if p x then f x else x) xs — применит функцию f только к тем элементам списка, для которых функция p вернет True;
concat [[x,y,z],[a,b,c,d,e],[o,p,r,s,t]] — из списка списков вернет список элементов всех списков [x,y,z,a,b,c,d,e,o,p,r,s,t];
zip xs ys — вернет список пар вида (x,y), в каждой из которых первый элемент x является очередным элементом первого списка xs, а второй элемент y — второго списка ys;
zip xs [0..] — нумерация (альтернативная, ср. с п.3.1) элементов списка (так, например, zip ['a','b','c'] [0..] даст [('a',0), ('b',1), ('c',2)]);

import qualified Data.List
либо явно указывать импортируемые функции из числа тех, что не определены в Prelude:

import Data.List(delete)
Перечислим ряд полезных функций, эмулирующих работу со списками как со множествами:

nub xs – возвращает список, в котором удалены повторяющиеся элементы;
delete x xs – удаляет первое вхождение заданного элемента x из списка xs;
sortBy p xs – осуществляет сортировку списка xs, используя специальным образом заданную программистом функцию p;
union xs ys – возвращает объединение двух списков;
intersect xs ys – возвращает пересечение двух списков;
(\\) – возвращает разность (неассоциативную) двух списков, таким образом: (xs ++ ys) \\ xs == ys (если нет общих элементов);
elem x xs – предикат, возвращающий истину, если элемент x принадлежит списку xs;
tails xs – функция возвращает список хвостов данного списка, напр.:
tails "abc" == ["abc", "bc", "c", ""]
isPrefixOf, isSuffixOf, isInfixOf – предикаты, принимающие два аргумента-списка list1 и list2, и возвращающие True, если list1 является приставкой, окончанием или содержится где-то в списке list2.

3.8.2 Поиск и замена в списках
Модуль Data.List предоставляет ряд функций, полезных для реализации функций поиска и замены в списках. Помимо уже указанных (!!), elem есть следующие:

find p xs – возвращает первый элемент в списке xs (обернутый конструктором Just), который удовлетворяет предикату p или Nothing в противном случае;
findIndex p xs – возвращает индекс первого элемента в списке xs (обернутый конструктором Just), который удовлетворяет предикату p или Nothing в противном случае;
filter p xs – возвращает подсписок списка xs, элементы которого удовлетворяют предикату p.

